---
title: "Fee Calculation"
description: "Understand how ZIP 317 fees work in t2z"
---

t2z automatically calculates fees according to [ZIP 317](https://zips.z.cash/zip-0317). This guide explains how fees work and how to predict them.

## ZIP 317 Formula

```
fee = marginal_fee × max(grace_actions, logical_actions)
```

Where:
- `marginal_fee` = 5,000 zatoshis
- `grace_actions` = 2
- `logical_actions` = max(transparent_inputs, transparent_outputs) + orchard_actions

## Examples

| Scenario | Logical Actions | Fee |
|----------|-----------------|-----|
| 1 t-in → 1 Orchard out | max(1,0) + 2 = 3 | 15,000 |
| 1 t-in → 2 Orchard out | max(1,0) + 2 = 3 | 15,000 |
| 2 t-in → 1 Orchard out | max(2,0) + 2 = 4 | 20,000 |
| 1 t-in → 1 t-out + 1 Orchard | max(1,1) + 2 = 3 | 15,000 |

<Note>
  Orchard always has a minimum of 2 actions (for privacy), so even 1 Orchard output counts as 2 actions.
</Note>

## Getting the Actual Fee

After proposing a transaction, use `inspect_pczt` to see the calculated fee:

```typescript
const pczt = t2z.propose_transaction(inputs, payments, changeAddr, network, expiry);
const info = t2z.inspect_pczt(pczt.to_hex());

console.log('Fee:', info.implied_fee, 'zatoshis');
console.log('Fee:', info.implied_fee / 100_000_000, 'ZEC');
```

## Predicting Fees

To estimate fees before building a transaction:

```typescript
function estimateFee(
  transparentInputs: number,
  transparentOutputs: number,
  orchardOutputs: number
): bigint {
  const MARGINAL_FEE = 5000n;
  const GRACE_ACTIONS = 2;
  
  // Orchard minimum is 2 actions
  const orchardActions = orchardOutputs > 0 ? Math.max(2, orchardOutputs) : 0;
  
  const logicalActions = Math.max(transparentInputs, transparentOutputs) + orchardActions;
  const actions = Math.max(GRACE_ACTIONS, logicalActions);
  
  return MARGINAL_FEE * BigInt(actions);
}

// Example: 1 input, 2 Orchard outputs (payment + change)
const fee = estimateFee(1, 0, 2);  // 15,000 zatoshis
```

## Change and Fees

When change goes to Orchard (recommended for privacy), it adds to the Orchard action count:

```
1 input → 1 Orchard payment + Orchard change
  = 1 transparent input + 2 Orchard outputs
  = max(1, 0) + max(2, 2) = 3 logical actions
  = max(2, 3) = 3 actions
  = 15,000 zatoshis
```

If change would go to transparent:

```
1 input → 1 Orchard payment + 1 transparent change
  = max(1, 1) + 2 = 3 actions
  = 15,000 zatoshis
```

## Fee Optimization

### Minimize Inputs

Consolidate UTXOs when possible:

```typescript
// Less efficient: 3 inputs
const fee1 = estimateFee(3, 0, 1);  // 25,000 (5 actions)

// More efficient: 1 input (if you have a larger UTXO)
const fee2 = estimateFee(1, 0, 1);  // 15,000 (3 actions)
```

### Batch Payments

Multiple Orchard payments can be more efficient:

```typescript
// Two separate transactions
const fee1 = estimateFee(1, 0, 1) * 2n;  // 30,000 (2 × 15,000)

// One transaction with 2 Orchard outputs
const fee2 = estimateFee(1, 0, 2);  // 15,000 (same fee, double the outputs!)
```

## Insufficient Funds

If you get an `InsufficientFunds` error, calculate the minimum input needed:

```typescript
const paymentAmount = 1_000_000n;  // 0.01 ZEC
const estimatedFee = 15_000n;       // Typical fee for 1 Orchard output

// Minimum input needed
const minInput = paymentAmount + estimatedFee;
console.log('Need at least:', minInput, 'zatoshis');
```

<Tip>
  When selecting UTXOs, add a small buffer (e.g., 15,000 zatoshis) to account for fees and potential change.
</Tip>
